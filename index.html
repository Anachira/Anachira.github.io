<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEAT_ALLOCATION_SYSTEM_V3.0_ONLINE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // グローバル変数として公開（既存のロジックから呼び出すため）
        window.db = db;
        window.auth = auth;
        window.doc = doc;
        window.setDoc = setDoc;
        window.appId = appId;

        // 認証と初期化
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed", error);
                updateStatus("AUTH_ERROR", "red");
            }
        };

        initAuth();

        // 認証状態を監視してリスナーを設定
        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log("User authenticated:", user.uid);
                setupRealtimeListener();
            }
        });

        // リアルタイムリスナーの設定
        function setupRealtimeListener() {
            if (!auth.currentUser) return;
            const seatsDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'seats', 'current_layout');

            onSnapshot(seatsDocRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    // データがある場合は反映
                    const data = docSnapshot.data();
                    window.updateSeatsFromCloud(data.seats);
                    updateStatus("SYNCED", "green");
                } else {
                    // データがない場合は初期化（最初の1人）
                    updateStatus("INITIALIZING_DB...", "yellow");
                    window.initializeCloudData();
                }
            }, (error) => {
                console.error("Sync error", error);
                updateStatus("CONNECTION_LOST", "red");
            });
        }

        function updateStatus(text, color) {
            const statusEl = document.getElementById('connection-status');
            if (statusEl) {
                statusEl.innerText = text;
                statusEl.className = `text-xs font-mono text-${color}-500`;
            }
        }
    </script>

    <style>
        /* ハッカー風の等幅フォント + 日本語フォント */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Noto+Sans+JP:wght@700&display=swap');
        
        :root {
            --bg-color: #050505;
            --main-color: #00ff41; /* Matrix Green */
            --text-glow: #a8ffb6; /* 文字の光彩 */
            --dim-color: #008f11;
            --alert-color: #ff3333;
            --glass-bg: rgba(0, 20, 0, 0.7);
        }

        body {
            font-family: 'Share Tech Mono', 'Noto Sans JP', monospace;
            background-color: var(--bg-color);
            color: var(--main-color);
            /* CRTモニターのような走査線エフェクト */
            background-image: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            min-height: 100vh;
            text-transform: uppercase;
        }

        /* 画面全体のちらつき */
        @keyframes flicker {
            0% { opacity: 0.97; }
            5% { opacity: 0.95; }
            10% { opacity: 0.9; }
            15% { opacity: 0.95; }
            100% { opacity: 0.97; }
        }
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        .terminal-box {
            border: 1px solid var(--main-color);
            background-color: rgba(0, 20, 0, 0.85);
            box-shadow: 0 0 15px var(--dim-color);
            position: relative;
        }
        
        .terminal-box::before {
            content: ''; position: absolute; top: -1px; left: -1px; width: 10px; height: 10px;
            border-top: 2px solid var(--main-color); border-left: 2px solid var(--main-color);
        }
        .terminal-box::after {
            content: ''; position: absolute; bottom: -1px; right: -1px; width: 10px; height: 10px;
            border-bottom: 2px solid var(--main-color); border-right: 2px solid var(--main-color);
        }

        .seat {
            aspect-ratio: 4/3;
            cursor: pointer;
            border: 1px solid var(--dim-color);
            background: rgba(0, 10, 0, 0.7);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* スムーズなアニメーション */
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .seat:hover {
            border-color: var(--main-color);
            box-shadow: inset 0 0 20px var(--dim-color);
            background: rgba(0, 40, 0, 0.9);
            z-index: 10;
        }

        .seat.dragging {
            opacity: 0.5;
            border: 2px dashed var(--main-color);
        }

        /* 名前のスタイル */
        .seat-content {
            pointer-events: none;
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            line-height: 1.3;
            letter-spacing: 0.05em;
            color: #ffffff;
            text-shadow: 
                0 0 5px var(--main-color),
                0 0 10px var(--dim-color);
            width: 100%;
            word-break: break-all;
        }

        /* ロック状態 */
        .locked {
            border-color: var(--alert-color) !important;
            box-shadow: inset 0 0 10px rgba(100, 0, 0, 0.5);
        }
        .locked .seat-content {
            text-shadow: 0 0 5px var(--alert-color);
            color: #ffebeb;
        }
        .locked::after {
            content: '[LOCKED]';
            position: absolute;
            top: 2px; right: 2px;
            font-size: 0.6rem;
            color: var(--alert-color);
            font-family: 'Share Tech Mono', monospace;
            opacity: 0.8;
        }

        .btn-cli {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid var(--main-color);
            color: var(--main-color);
            font-family: 'Share Tech Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
        }
        .btn-cli:hover {
            background: var(--main-color);
            color: #000;
            box-shadow: 0 0 15px var(--main-color);
            font-weight: bold;
        }

        /* 黒板エリア */
        .blackboard {
            border: 1px solid var(--dim-color);
            color: var(--dim-color);
            font-size: 0.9rem;
            font-weight: bold;
            text-align: center;
            background: repeating-linear-gradient(
                45deg,
                rgba(0,0,0,0.8),
                rgba(0,0,0,0.8) 10px,
                rgba(0,30,0,0.8) 10px,
                rgba(0,30,0,0.8) 20px
            );
            text-shadow: 0 0 3px var(--dim-color);
        }

        /* モーダル */
        .modal-bg {
            background: rgba(5, 5, 5, 0.95);
            border: 1px solid var(--main-color);
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.2);
        }
        
        input[type="text"] {
            background: #000;
            border: 1px solid var(--dim-color);
            color: var(--main-color);
            font-family: 'Noto Sans JP', monospace;
            font-weight: bold;
            font-size: 1.1rem;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: var(--main-color);
            box-shadow: 0 0 15px var(--dim-color);
        }

        .blinking-cursor::after {
            content: '_';
            animation: blink 1s step-end infinite;
            margin-left: 5px;
        }
        @keyframes blink { 50% { opacity: 0; } }

        @media print {
            body { background: white; color: black; background-image: none; }
            .seat { border: 2px solid #000; color: #000; background: white; }
            .seat-content { color: #000; text-shadow: none; font-weight: bold; }
            .terminal-box { border: 2px solid #000; box-shadow: none; background: white; }
            .no-print { display: none; }
            .locked::after { color: #000; }
        }
    </style>
</head>
<body class="flex flex-col items-center py-6 px-2 sm:px-4">

    <!-- ヘッダー -->
    <header class="w-full max-w-5xl mb-6 flex flex-col sm:flex-row justify-between items-end terminal-box p-6 no-print gap-4">
        <div>
            <h1 class="text-2xl sm:text-4xl font-bold tracking-widest blinking-cursor" style="text-shadow: 0 0 10px var(--main-color);">
                SYSTEM: CLASS_2-6_LAYOUT
            </h1>
            <p class="text-xs sm:text-sm opacity-80 mt-2 font-mono text-green-400">
                > ACCESS_LEVEL: ADMINISTRATOR<br>
                > MODULE: REALTIME_SYNC_V3.0<br>
                > STATUS: <span id="connection-status" class="text-yellow-500">CONNECTING...</span>
            </p>
        </div>
        <div class="flex flex-wrap gap-3 justify-end">
            <!-- 手動シャッフルボタンを追加 -->
            <button onclick="shuffleSeats()" class="btn-cli px-6 py-3 flex items-center gap-2 font-bold">
                [ AUTO_SHUFFLE ]
            </button>
            <button onclick="downloadImage()" class="btn-cli px-6 py-3 flex items-center gap-2 font-bold">
                [ EXPORT_IMAGE ]
            </button>
        </div>
    </header>

    <!-- メインエリア -->
    <main id="classroom-area" class="w-full max-w-5xl terminal-box p-4 sm:p-8 relative">
        
        <!-- コンソールログ風装飾 -->
        <div class="absolute top-3 left-4 text-[0.7rem] text-green-600 font-mono hidden sm:block leading-tight">
            > RENDER_ENGINE: ONLINE<br>
            > SYNC_PROTOCOL: FIRESTORE<br>
            > LATENCY: <span id="latency-val">--</span>ms
        </div>

        <!-- 座席グリッド -->
        <div id="seat-grid" class="grid grid-cols-6 gap-3 sm:gap-5 mb-8 mt-10 relative z-10">
            <!-- JSで生成 -->
        </div>

        <!-- 黒板 (システムディスプレイ風) -->
        <div class="w-full flex justify-center mb-2 mt-6 relative z-10">
            <div class="blackboard w-2/3 h-16 flex items-center justify-center tracking-widest">
                [ FRONT_AREA / WHITEBOARD ]
            </div>
        </div>

        <div class="flex justify-between items-end mt-6 border-t border-green-900 pt-3">
            <div class="text-xs text-green-600 font-mono">
                SECURE_CONNECTION: ENCRYPTED
            </div>
            <div class="text-right text-xs sm:text-sm opacity-70 font-mono">
                LAST_UPDATE: <span id="current-date"></span>
            </div>
        </div>
    </main>

    <!-- 編集モーダル -->
    <div id="edit-modal" class="fixed inset-0 bg-black bg-opacity-90 hidden items-center justify-center z-50 backdrop-blur-sm">
        <div class="modal-bg p-8 w-96 shadow-2xl relative">
            <div class="absolute top-0 left-0 w-full h-1 bg-green-500 box-shadow-glow"></div>
            
            <h3 class="text-xl font-bold mb-6 flex items-center gap-2 border-b border-green-900 pb-3 text-white" style="text-shadow: 0 0 8px var(--main-color);">
                >> EDIT_STUDENT_DATA
            </h3>
            
            <div class="mb-8">
                <label class="block text-xs font-bold mb-2 text-green-400 font-mono">TARGET_NAME_INPUT:</label>
                <input type="text" id="edit-name-input" class="w-full px-4 py-3 text-lg">
            </div>
            
            <div class="flex items-center mb-10 cursor-pointer p-2 border border-transparent hover:border-green-900 transition" onclick="document.getElementById('edit-lock-check').click()">
                <input type="checkbox" id="edit-lock-check" class="h-5 w-5 bg-black border-green-500 rounded-none accent-green-500 cursor-pointer">
                <label for="edit-lock-check" class="ml-4 block text-sm font-bold cursor-pointer select-none text-white">
                    ENABLE_POSITION_LOCK
                </label>
            </div>
            
            <div class="flex justify-end gap-4">
                <button onclick="closeModal()" class="px-6 py-2 text-sm border border-gray-700 text-gray-400 hover:border-gray-500 hover:text-white transition font-mono">CANCEL</button>
                <button onclick="saveEdit()" class="btn-cli px-8 py-3 text-sm bg-green-900 bg-opacity-30 font-bold">SAVE_DATA</button>
            </div>
        </div>
    </div>

    <script>
        // 座席データ初期値 (6行 x 6列)
        const initialSeatsData = [
            ["田島 大暉", "河田 愛子", "山中 壱磋", "遠藤 結衣", "大谷 和輝", "中村 颯南"],
            ["大曽根 維月", "藤澤 志帆", "園部 可憐", "田家 瑶姫", "猪野 夢奈", "丸山 晴生"],
            ["山崎 しおん", "小嶋 杏奈", "佐藤 璃音", "渡邉 美空", "会田 心穏", "尾形 勇飛"],
            ["相場 日菜詩", "齋藤 優", "小川 快晴", "水口 夏悟", "佐々木 琉斗", "大川 める"],
            ["岡田 悠斗", "室井 陽人", "海老原 穂鷹", "内藤 倖一朗", "薄井 駿介", "小林 智宥"],
            ["", "有年 禅", "馬場 美幸", "鈴木 杏奈", "秋葉 心愛", ""]
        ];

        let seats = []; 
        let draggingSeatIndex = null;
        let editingSeatIndex = null;

        // --- Cloud Sync Functions ---

        // 初期データをクラウドに送信（初回のみ）
        window.initializeCloudData = async function() {
            if (!window.auth.currentUser) return; // ガード
            console.log("Initializing Cloud Data...");
            seats = [];
            let index = 0;
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 6; c++) {
                    const name = initialSeatsData[r][c];
                    seats.push({
                        id: index,
                        name: name,
                        locked: false
                    });
                    index++;
                }
            }
            await uploadSeatsToCloud(seats);
        }

        // クラウドからのデータでローカルを更新
        window.updateSeatsFromCloud = function(cloudSeats) {
            seats = cloudSeats;
            renderSeats();
            // 日時更新
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 19).replace('T', ' ');
            document.getElementById('current-date').textContent = dateStr;
            // レイテンシー擬似表示
            document.getElementById('latency-val').textContent = Math.floor(Math.random() * 20 + 10);
        }

        // データをクラウドに保存
        async function uploadSeatsToCloud(newSeats) {
            if (!window.db || !window.appId || !window.auth.currentUser) return; // authチェック追加
            try {
                const docRef = window.doc(window.db, 'artifacts', window.appId, 'public', 'data', 'seats', 'current_layout');
                await window.setDoc(docRef, {
                    seats: newSeats,
                    lastUpdated: new Date().toISOString()
                });
            } catch (e) {
                console.error("Upload failed", e);
                alert("SYNC_ERROR: DATA_UPLOAD_FAILED");
            }
        }

        // --- View Logic ---

        function renderSeats() {
            const grid = document.getElementById('seat-grid');
            grid.innerHTML = '';

            seats.forEach((seat, index) => {
                const el = document.createElement('div');
                let classes = `seat flex flex-col items-center justify-center text-center p-1 relative`;
                if (seat.locked) classes += ' locked';
                if (!seat.name) classes += ' opacity-40'; 
                
                el.className = classes;
                el.draggable = true;
                el.dataset.index = index;

                el.addEventListener('dragstart', handleDragStart);
                el.addEventListener('dragover', handleDragOver);
                el.addEventListener('drop', handleDrop);
                el.addEventListener('dragend', handleDragEnd);
                el.addEventListener('touchstart', handleTouchStart, {passive: false});
                el.addEventListener('touchmove', handleTouchMove, {passive: false});
                el.addEventListener('touchend', handleTouchEnd);
                el.addEventListener('click', () => openModal(index));

                // IDラベル
                const idxLabel = document.createElement('div');
                idxLabel.className = 'absolute top-1 left-1 text-[0.6rem] text-green-800 font-mono pointer-events-none';
                idxLabel.innerText = `${String(index).padStart(2, '0')}`;
                el.appendChild(idxLabel);

                const content = document.createElement('div');
                content.className = 'seat-content w-full break-words z-10';
                
                if (seat.name) {
                    content.innerHTML = seat.name.replace(' ', '<br>');
                } else {
                    content.innerHTML = '<span class="text-[0.8rem] opacity-30 font-mono">[ NULL ]</span>';
                }
                
                el.appendChild(content);
                grid.appendChild(el);
            });
        }

        // --- ドラッグ＆ドロップ ---
        function handleDragStart(e) {
            draggingSeatIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        function handleDrop(e) {
            e.stopPropagation();
            const targetIndex = parseInt(this.dataset.index);
            if (draggingSeatIndex !== null && draggingSeatIndex !== targetIndex) {
                swapSeats(draggingSeatIndex, targetIndex);
            }
            return false;
        }
        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggingSeatIndex = null;
        }

        let touchDragSrc = null;
        function handleTouchStart(e) {
            touchDragSrc = this;
            this.classList.add('dragging');
        }
        function handleTouchMove(e) { e.preventDefault(); }
        function handleTouchEnd(e) {
            this.classList.remove('dragging');
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetSeat = target ? target.closest('.seat') : null;
            if (targetSeat && touchDragSrc && targetSeat !== touchDragSrc) {
                const srcIndex = parseInt(touchDragSrc.dataset.index);
                const targetIndex = parseInt(targetSeat.dataset.index);
                swapSeats(srcIndex, targetIndex);
            }
            touchDragSrc = null;
        }

        // 席替え処理（クラウドへ反映）
        async function swapSeats(idx1, idx2) {
            // ローカルで即時反映（UX向上のため）
            const newSeats = JSON.parse(JSON.stringify(seats)); // Deep copy
            
            const tempName = newSeats[idx1].name;
            const tempLock = newSeats[idx1].locked;
            
            newSeats[idx1].name = newSeats[idx2].name;
            newSeats[idx1].locked = newSeats[idx2].locked;
            
            newSeats[idx2].name = tempName;
            newSeats[idx2].locked = tempLock;
            
            // クラウドへ送信
            await uploadSeatsToCloud(newSeats);
        }

        // --- 編集モーダル ---
        function openModal(index) {
            editingSeatIndex = index;
            const seat = seats[index];
            document.getElementById('edit-name-input').value = seat.name;
            document.getElementById('edit-lock-check').checked = seat.locked;
            const modal = document.getElementById('edit-modal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            document.getElementById('edit-name-input').focus();
        }
        function closeModal() {
            const modal = document.getElementById('edit-modal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            editingSeatIndex = null;
        }
        
        async function saveEdit() {
            if (editingSeatIndex !== null) {
                const newName = document.getElementById('edit-name-input').value;
                const isLocked = document.getElementById('edit-lock-check').checked;
                
                const newSeats = JSON.parse(JSON.stringify(seats));
                newSeats[editingSeatIndex].name = newName;
                newSeats[editingSeatIndex].locked = isLocked;
                
                await uploadSeatsToCloud(newSeats);
                closeModal();
            }
        }

        // --- シャッフル機能 ---
        async function shuffleSeats() {
            if (!confirm('WARNING: EXECUTE RANDOM SHUFFLE SEQUENCE?\n(Locked seats will remain unchanged)')) return;

            const newSeats = JSON.parse(JSON.stringify(seats));
            
            let movableStudents = [];
            let availableIndices = [];

            newSeats.forEach((seat, index) => {
                if (!seat.locked) {
                    availableIndices.push(index);
                    movableStudents.push(seat.name);
                }
            });

            // Fisher-Yates Shuffle
            for (let i = movableStudents.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [movableStudents[i], movableStudents[j]] = [movableStudents[j], movableStudents[i]];
            }

            availableIndices.forEach((seatIndex, i) => {
                newSeats[seatIndex].name = movableStudents[i];
            });

            await uploadSeatsToCloud(newSeats);
        }

        // --- 画像保存 ---
        function downloadImage() {
            const element = document.getElementById('classroom-area');
            const originalBg = element.style.backgroundColor;
            element.style.backgroundColor = "#050505";
            
            html2canvas(element, {
                scale: 3,
                backgroundColor: "#050505",
            }).then(canvas => {
                element.style.backgroundColor = originalBg;
                const link = document.createElement('a');
                link.download = `SEAT_LAYOUT_${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

    </script>
</body>
</html>
